{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar DraftEntitySegments = require(\"./DraftEntitySegments\");\n\nvar getRangesForDraftEntity = require(\"./getRangesForDraftEntity\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n/**\n * Given a SelectionState and a removal direction, determine the entire range\n * that should be removed from a ContentState. This is based on any entities\n * within the target, with their `mutability` values taken into account.\n *\n * For instance, if we are attempting to remove part of an \"immutable\" entity\n * range, the entire entity must be removed. The returned `SelectionState`\n * will be adjusted accordingly.\n */\n\n\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var startEntityKey = startBlock.getEntityAt(start);\n  var endEntityKey = endBlock.getEntityAt(end - 1);\n\n  if (!startEntityKey && !endEntityKey) {\n    return selectionState;\n  }\n\n  var newSelectionState = selectionState;\n\n  if (startEntityKey && startEntityKey === endEntityKey) {\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\n  } else if (startEntityKey && endEntityKey) {\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: startSelectionState.getAnchorOffset(),\n      focusOffset: endSelectionState.getFocusOffset(),\n      isBackward: false\n    });\n  } else if (startEntityKey) {\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: _startSelectionState.getStartOffset(),\n      isBackward: false\n    });\n  } else if (endEntityKey) {\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n\n    newSelectionState = newSelectionState.merge({\n      focusOffset: _endSelectionState.getEndOffset(),\n      isBackward: false\n    });\n  }\n\n  return newSelectionState;\n}\n\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n\n  var entity = entityMap.__get(entityKey);\n\n  var mutability = entity.getMutability();\n  var sideToConsider = isEntityAtStart ? start : end; // `MUTABLE` entities can just have the specified range of text removed\n  // directly. No adjustments are needed.\n\n  if (mutability === 'MUTABLE') {\n    return selectionState;\n  } // Find the entity range that overlaps with our removal range.\n\n\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\n    return sideToConsider <= range.end && sideToConsider >= range.start;\n  });\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\n  var entityRange = entityRanges[0]; // For `IMMUTABLE` entity types, we will remove the entire entity range.\n\n  if (mutability === 'IMMUTABLE') {\n    return selectionState.merge({\n      anchorOffset: entityRange.start,\n      focusOffset: entityRange.end,\n      isBackward: false\n    });\n  } // For `SEGMENTED` entity types, determine the appropriate segment to\n  // remove.\n\n\n  if (!isEntireSelectionWithinEntity) {\n    if (isEntityAtStart) {\n      end = entityRange.end;\n    } else {\n      start = entityRange.start;\n    }\n  }\n\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\n  return selectionState.merge({\n    anchorOffset: removalRange.start,\n    focusOffset: removalRange.end,\n    isBackward: false\n  });\n}\n\nmodule.exports = getCharacterRemovalRange;","map":{"version":3,"names":["DraftEntitySegments","require","getRangesForDraftEntity","invariant","getCharacterRemovalRange","entityMap","startBlock","endBlock","selectionState","direction","start","getStartOffset","end","getEndOffset","startEntityKey","getEntityAt","endEntityKey","newSelectionState","getEntityRemovalRange","startSelectionState","endSelectionState","merge","anchorOffset","getAnchorOffset","focusOffset","getFocusOffset","isBackward","_startSelectionState","_endSelectionState","block","entityKey","isEntireSelectionWithinEntity","isEntityAtStart","entity","__get","mutability","getMutability","sideToConsider","entityRanges","filter","range","length","process","env","NODE_ENV","entityRange","removalRange","getRemovalRange","getText","slice","module","exports"],"sources":["/home/sudhanshu/Documents/combett/node_modules/draft-js/lib/getCharacterRemovalRange.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar DraftEntitySegments = require(\"./DraftEntitySegments\");\n\nvar getRangesForDraftEntity = require(\"./getRangesForDraftEntity\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n/**\n * Given a SelectionState and a removal direction, determine the entire range\n * that should be removed from a ContentState. This is based on any entities\n * within the target, with their `mutability` values taken into account.\n *\n * For instance, if we are attempting to remove part of an \"immutable\" entity\n * range, the entire entity must be removed. The returned `SelectionState`\n * will be adjusted accordingly.\n */\n\n\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var startEntityKey = startBlock.getEntityAt(start);\n  var endEntityKey = endBlock.getEntityAt(end - 1);\n\n  if (!startEntityKey && !endEntityKey) {\n    return selectionState;\n  }\n\n  var newSelectionState = selectionState;\n\n  if (startEntityKey && startEntityKey === endEntityKey) {\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\n  } else if (startEntityKey && endEntityKey) {\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: startSelectionState.getAnchorOffset(),\n      focusOffset: endSelectionState.getFocusOffset(),\n      isBackward: false\n    });\n  } else if (startEntityKey) {\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: _startSelectionState.getStartOffset(),\n      isBackward: false\n    });\n  } else if (endEntityKey) {\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n\n    newSelectionState = newSelectionState.merge({\n      focusOffset: _endSelectionState.getEndOffset(),\n      isBackward: false\n    });\n  }\n\n  return newSelectionState;\n}\n\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n\n  var entity = entityMap.__get(entityKey);\n\n  var mutability = entity.getMutability();\n  var sideToConsider = isEntityAtStart ? start : end; // `MUTABLE` entities can just have the specified range of text removed\n  // directly. No adjustments are needed.\n\n  if (mutability === 'MUTABLE') {\n    return selectionState;\n  } // Find the entity range that overlaps with our removal range.\n\n\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\n    return sideToConsider <= range.end && sideToConsider >= range.start;\n  });\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\n  var entityRange = entityRanges[0]; // For `IMMUTABLE` entity types, we will remove the entire entity range.\n\n  if (mutability === 'IMMUTABLE') {\n    return selectionState.merge({\n      anchorOffset: entityRange.start,\n      focusOffset: entityRange.end,\n      isBackward: false\n    });\n  } // For `SEGMENTED` entity types, determine the appropriate segment to\n  // remove.\n\n\n  if (!isEntireSelectionWithinEntity) {\n    if (isEntityAtStart) {\n      end = entityRange.end;\n    } else {\n      start = entityRange.start;\n    }\n  }\n\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\n  return selectionState.merge({\n    anchorOffset: removalRange.start,\n    focusOffset: removalRange.end,\n    isBackward: false\n  });\n}\n\nmodule.exports = getCharacterRemovalRange;"],"mappings":"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"},"metadata":{},"sourceType":"script"}