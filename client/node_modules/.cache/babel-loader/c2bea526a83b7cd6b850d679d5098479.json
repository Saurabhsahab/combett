{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar generateRandomKey = require(\"./generateRandomKey\");\n\nvar Immutable = require(\"immutable\");\n\nvar OrderedMap = Immutable.OrderedMap;\n\nvar randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {\n  var newKeysRef = {}; // we keep track of root blocks in order to update subsequent sibling links\n\n  var lastRootBlock;\n  return OrderedMap(blockMap.withMutations(function (blockMapState) {\n    blockMapState.forEach(function (block, index) {\n      var oldKey = block.getKey();\n      var nextKey = block.getNextSiblingKey();\n      var prevKey = block.getPrevSiblingKey();\n      var childrenKeys = block.getChildKeys();\n      var parentKey = block.getParentKey(); // new key that we will use to build linking\n\n      var key = generateRandomKey(); // we will add it here to re-use it later\n\n      newKeysRef[oldKey] = key;\n\n      if (nextKey) {\n        var nextBlock = blockMapState.get(nextKey);\n\n        if (nextBlock) {\n          blockMapState.setIn([nextKey, 'prevSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'nextSibling'], null);\n        }\n      }\n\n      if (prevKey) {\n        var prevBlock = blockMapState.get(prevKey);\n\n        if (prevBlock) {\n          blockMapState.setIn([prevKey, 'nextSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'prevSibling'], null);\n        }\n      }\n\n      if (parentKey && blockMapState.get(parentKey)) {\n        var parentBlock = blockMapState.get(parentKey);\n        var parentChildrenList = parentBlock.getChildKeys();\n        blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));\n      } else {\n        // blocks will then be treated as root block nodes\n        blockMapState.setIn([oldKey, 'parent'], null);\n\n        if (lastRootBlock) {\n          blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);\n          blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);\n        }\n\n        lastRootBlock = blockMapState.get(oldKey);\n      }\n\n      childrenKeys.forEach(function (childKey) {\n        var childBlock = blockMapState.get(childKey);\n\n        if (childBlock) {\n          blockMapState.setIn([childKey, 'parent'], key);\n        } else {\n          blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {\n            return child !== childKey;\n          }));\n        }\n      });\n    });\n  }).toArray().map(function (block) {\n    return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];\n  }));\n};\n\nvar randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {\n  return OrderedMap(blockMap.toArray().map(function (block) {\n    var key = generateRandomKey();\n    return [key, block.set('key', key)];\n  }));\n};\n\nvar randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n\n  if (!isTreeBasedBlockMap) {\n    return randomizeContentBlockKeys(blockMap);\n  }\n\n  return randomizeContentBlockNodeKeys(blockMap);\n};\n\nmodule.exports = randomizeBlockMapKeys;","map":{"version":3,"names":["ContentBlockNode","require","generateRandomKey","Immutable","OrderedMap","randomizeContentBlockNodeKeys","blockMap","newKeysRef","lastRootBlock","withMutations","blockMapState","forEach","block","index","oldKey","getKey","nextKey","getNextSiblingKey","prevKey","getPrevSiblingKey","childrenKeys","getChildKeys","parentKey","getParentKey","key","nextBlock","get","setIn","prevBlock","parentBlock","parentChildrenList","set","indexOf","childKey","childBlock","filter","child","toArray","map","randomizeContentBlockKeys","randomizeBlockMapKeys","isTreeBasedBlockMap","first","module","exports"],"sources":["/home/sudhanshu/Documents/combett/node_modules/draft-js/lib/randomizeBlockMapKeys.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar generateRandomKey = require(\"./generateRandomKey\");\n\nvar Immutable = require(\"immutable\");\n\nvar OrderedMap = Immutable.OrderedMap;\n\nvar randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {\n  var newKeysRef = {}; // we keep track of root blocks in order to update subsequent sibling links\n\n  var lastRootBlock;\n  return OrderedMap(blockMap.withMutations(function (blockMapState) {\n    blockMapState.forEach(function (block, index) {\n      var oldKey = block.getKey();\n      var nextKey = block.getNextSiblingKey();\n      var prevKey = block.getPrevSiblingKey();\n      var childrenKeys = block.getChildKeys();\n      var parentKey = block.getParentKey(); // new key that we will use to build linking\n\n      var key = generateRandomKey(); // we will add it here to re-use it later\n\n      newKeysRef[oldKey] = key;\n\n      if (nextKey) {\n        var nextBlock = blockMapState.get(nextKey);\n\n        if (nextBlock) {\n          blockMapState.setIn([nextKey, 'prevSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'nextSibling'], null);\n        }\n      }\n\n      if (prevKey) {\n        var prevBlock = blockMapState.get(prevKey);\n\n        if (prevBlock) {\n          blockMapState.setIn([prevKey, 'nextSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'prevSibling'], null);\n        }\n      }\n\n      if (parentKey && blockMapState.get(parentKey)) {\n        var parentBlock = blockMapState.get(parentKey);\n        var parentChildrenList = parentBlock.getChildKeys();\n        blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));\n      } else {\n        // blocks will then be treated as root block nodes\n        blockMapState.setIn([oldKey, 'parent'], null);\n\n        if (lastRootBlock) {\n          blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);\n          blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);\n        }\n\n        lastRootBlock = blockMapState.get(oldKey);\n      }\n\n      childrenKeys.forEach(function (childKey) {\n        var childBlock = blockMapState.get(childKey);\n\n        if (childBlock) {\n          blockMapState.setIn([childKey, 'parent'], key);\n        } else {\n          blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {\n            return child !== childKey;\n          }));\n        }\n      });\n    });\n  }).toArray().map(function (block) {\n    return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];\n  }));\n};\n\nvar randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {\n  return OrderedMap(blockMap.toArray().map(function (block) {\n    var key = generateRandomKey();\n    return [key, block.set('key', key)];\n  }));\n};\n\nvar randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n\n  if (!isTreeBasedBlockMap) {\n    return randomizeContentBlockKeys(blockMap);\n  }\n\n  return randomizeContentBlockNodeKeys(blockMap);\n};\n\nmodule.exports = randomizeBlockMapKeys;"],"mappings":"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"},"metadata":{},"sourceType":"script"}