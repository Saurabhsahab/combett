{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar BlockMapBuilder = require(\"./BlockMapBuilder\");\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar Immutable = require(\"immutable\");\n\nvar insertIntoList = require(\"./insertIntoList\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar randomizeBlockMapKeys = require(\"./randomizeBlockMapKeys\");\n\nvar List = Immutable.List;\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var mergeBlockData = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'REPLACE_WITH_NEW_DATA';\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n  var data = null;\n\n  switch (mergeBlockData) {\n    case 'MERGE_OLD_DATA_TO_NEW_DATA':\n      data = fragmentBlock.getData().merge(targetBlock.getData());\n      break;\n\n    case 'REPLACE_WITH_NEW_DATA':\n      data = fragmentBlock.getData();\n      break;\n  }\n\n  var type = targetBlock.getType();\n\n  if (text && type === 'unstyled') {\n    type = fragmentBlock.getType();\n  }\n\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    type: type,\n    data: data\n  });\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\n\n\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\n\n\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = []; // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    } // update the last root block fragment\n\n\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey); // update the original target next block\n\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    } // update fragment parent links\n\n\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    }); // update targetBlock parent child links\n\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray(); // insert fragment children\n\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    } // Insert fragment blocks after the head and before the tail.\n\n\n    fragment // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    }); // update tail\n\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  var mergeBlockData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'REPLACE_WITH_NEW_DATA';\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  } // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n\n\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset, mergeBlockData);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;","map":{"version":3,"names":["BlockMapBuilder","require","ContentBlockNode","Immutable","insertIntoList","invariant","randomizeBlockMapKeys","List","updateExistingBlock","contentState","selectionState","blockMap","fragmentBlock","targetKey","targetOffset","mergeBlockData","arguments","length","undefined","targetBlock","get","text","getText","chars","getCharacterList","finalKey","finalOffset","data","getData","merge","type","getType","newBlock","slice","characterList","set","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","updateHead","block","fragment","headText","headCharacters","appendToHead","first","concat","updateTail","blockSize","tailText","tailCharacters","prependToTail","last","getRootBlocks","headKey","getKey","rootBlock","rootBlocks","push","getNextSiblingKey","lastSiblingKey","updateBlockMapLinks","originalBlockMap","fragmentHeadBlock","withMutations","blockMapState","targetNextKey","targetParentKey","getParentKey","fragmentRootBlocks","lastRootFragmentBlockKey","setIn","forEach","blockKey","targetParent","originalTargetParentChildKeys","getChildKeys","targetBlockIndex","indexOf","insertionIndex","newChildrenKeysArray","toArray","splice","apply","insertFragment","isTreeBasedBlockMap","newBlockArr","fragmentSize","size","target","head","tail","getLength","shouldNotUpdateFromFragmentBlock","isEmpty","updatedBlockMap","createFromArray","insertFragmentIntoContentState","fragmentBlockMap","isCollapsed","process","env","NODE_ENV","getBlockMap","getStartKey","getStartOffset","module","exports"],"sources":["/home/sudhanshu/Documents/combett/node_modules/draft-js/lib/insertFragmentIntoContentState.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar BlockMapBuilder = require(\"./BlockMapBuilder\");\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar Immutable = require(\"immutable\");\n\nvar insertIntoList = require(\"./insertIntoList\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar randomizeBlockMapKeys = require(\"./randomizeBlockMapKeys\");\n\nvar List = Immutable.List;\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var mergeBlockData = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'REPLACE_WITH_NEW_DATA';\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n  var data = null;\n\n  switch (mergeBlockData) {\n    case 'MERGE_OLD_DATA_TO_NEW_DATA':\n      data = fragmentBlock.getData().merge(targetBlock.getData());\n      break;\n\n    case 'REPLACE_WITH_NEW_DATA':\n      data = fragmentBlock.getData();\n      break;\n  }\n\n  var type = targetBlock.getType();\n\n  if (text && type === 'unstyled') {\n    type = fragmentBlock.getType();\n  }\n\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    type: type,\n    data: data\n  });\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\n\n\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\n\n\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = []; // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    } // update the last root block fragment\n\n\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey); // update the original target next block\n\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    } // update fragment parent links\n\n\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    }); // update targetBlock parent child links\n\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray(); // insert fragment children\n\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    } // Insert fragment blocks after the head and before the tail.\n\n\n    fragment // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    }); // update tail\n\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  var mergeBlockData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'REPLACE_WITH_NEW_DATA';\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  } // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n\n\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset, mergeBlockData);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;"],"mappings":"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"},"metadata":{},"sourceType":"script"}