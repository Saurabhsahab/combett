{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar getNextDelimiterBlockKey = require(\"./getNextDelimiterBlockKey\");\n\nvar Immutable = require(\"immutable\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar OrderedMap = Immutable.OrderedMap,\n    List = Immutable.List;\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\n  if (!isExperimentalTreeBlock) {\n    return blockMap;\n  } // possible values of 'insertionMode' are: 'after', 'before'\n\n\n  var isInsertedAfterTarget = insertionMode === 'after';\n  var originalBlockKey = originalBlockToBeMoved.getKey();\n  var originalTargetKey = originalTargetBlock.getKey();\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\n  var newParentKey = originalTargetBlock.getParentKey();\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\n  return blockMap.withMutations(function (blocks) {\n    // update old parent\n    transformBlock(originalParentKey, blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      return block.merge({\n        children: parentChildrenList[\"delete\"](parentChildrenList.indexOf(originalBlockKey))\n      });\n    }); // update old prev\n\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalNextSiblingKey\n      });\n    }); // update old next\n\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalPrevSiblingKey\n      });\n    }); // update new next\n\n    transformBlock(newNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    }); // update new prev\n\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalBlockKey\n      });\n    }); // update new parent\n\n    transformBlock(newParentKey, blocks, function (block) {\n      var newParentChildrenList = block.getChildKeys();\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\n      var newChildrenArray = newParentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    }); // update block\n\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: newNextSiblingKey,\n        prevSibling: newPrevSiblingKey,\n        parent: newParentKey\n      });\n    });\n  });\n};\n\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\n  var targetKey = targetBlock.getKey();\n  var blockKey = blockToBeMoved.getKey();\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\n  var blocksToBeMoved = [blockToBeMoved];\n  var blockMapWithoutBlocksToBeMoved = blockMap[\"delete\"](blockKey);\n\n  if (isExperimentalTreeBlock) {\n    blocksToBeMoved = [];\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\n      blocks.toSeq().skipUntil(function (block) {\n        return block.getKey() === blockKey;\n      }).takeWhile(function (block) {\n        var key = block.getKey();\n        var isBlockToBeMoved = key === blockKey;\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\n      }).forEach(function (block) {\n        blocksToBeMoved.push(block);\n        blocks[\"delete\"](block.getKey());\n      });\n    });\n  }\n\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\n    return v === targetBlock;\n  });\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\n    return v === targetBlock;\n  }).skip(1);\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\n    return [block.getKey(), block];\n  });\n  var newBlocks = OrderedMap();\n\n  if (insertionMode === 'before') {\n    var blockBefore = contentState.getBlockBefore(targetKey);\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\n  } else if (insertionMode === 'after') {\n    var blockAfter = contentState.getBlockAfter(targetKey);\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\n  }\n\n  return contentState.merge({\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\n    selectionBefore: contentState.getSelectionAfter(),\n    selectionAfter: contentState.getSelectionAfter().merge({\n      anchorKey: blockKey,\n      focusKey: blockKey\n    })\n  });\n};\n\nmodule.exports = moveBlockInContentState;","map":{"version":3,"names":["ContentBlockNode","require","getNextDelimiterBlockKey","Immutable","invariant","OrderedMap","List","transformBlock","key","blockMap","func","block","get","set","updateBlockMapLinks","originalBlockToBeMoved","originalTargetBlock","insertionMode","isExperimentalTreeBlock","isInsertedAfterTarget","originalBlockKey","getKey","originalTargetKey","originalParentKey","getParentKey","originalNextSiblingKey","getNextSiblingKey","originalPrevSiblingKey","getPrevSiblingKey","newParentKey","newNextSiblingKey","newPrevSiblingKey","withMutations","blocks","parentChildrenList","getChildKeys","merge","children","indexOf","nextSibling","prevSibling","newParentChildrenList","targetBlockIndex","insertionIndex","newChildrenArray","toArray","splice","parent","moveBlockInContentState","contentState","blockToBeMoved","targetBlock","process","env","NODE_ENV","targetKey","blockKey","getBlockMap","blocksToBeMoved","blockMapWithoutBlocksToBeMoved","nextSiblingKey","nextDelimiterBlockKey","toSeq","skipUntil","takeWhile","isBlockToBeMoved","hasNextSiblingAndIsNotNextSibling","doesNotHaveNextSiblingAndIsNotDelimiter","forEach","push","blocksBefore","takeUntil","v","blocksAfter","skip","slicedBlocks","map","newBlocks","blockBefore","getBlockBefore","concat","toOrderedMap","blockAfter","getBlockAfter","selectionBefore","getSelectionAfter","selectionAfter","anchorKey","focusKey","module","exports"],"sources":["/home/sudhanshu/Documents/combett/node_modules/draft-js/lib/moveBlockInContentState.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar getNextDelimiterBlockKey = require(\"./getNextDelimiterBlockKey\");\n\nvar Immutable = require(\"immutable\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar OrderedMap = Immutable.OrderedMap,\n    List = Immutable.List;\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\n  if (!isExperimentalTreeBlock) {\n    return blockMap;\n  } // possible values of 'insertionMode' are: 'after', 'before'\n\n\n  var isInsertedAfterTarget = insertionMode === 'after';\n  var originalBlockKey = originalBlockToBeMoved.getKey();\n  var originalTargetKey = originalTargetBlock.getKey();\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\n  var newParentKey = originalTargetBlock.getParentKey();\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\n  return blockMap.withMutations(function (blocks) {\n    // update old parent\n    transformBlock(originalParentKey, blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      return block.merge({\n        children: parentChildrenList[\"delete\"](parentChildrenList.indexOf(originalBlockKey))\n      });\n    }); // update old prev\n\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalNextSiblingKey\n      });\n    }); // update old next\n\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalPrevSiblingKey\n      });\n    }); // update new next\n\n    transformBlock(newNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    }); // update new prev\n\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalBlockKey\n      });\n    }); // update new parent\n\n    transformBlock(newParentKey, blocks, function (block) {\n      var newParentChildrenList = block.getChildKeys();\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\n      var newChildrenArray = newParentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    }); // update block\n\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: newNextSiblingKey,\n        prevSibling: newPrevSiblingKey,\n        parent: newParentKey\n      });\n    });\n  });\n};\n\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\n  var targetKey = targetBlock.getKey();\n  var blockKey = blockToBeMoved.getKey();\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\n  var blocksToBeMoved = [blockToBeMoved];\n  var blockMapWithoutBlocksToBeMoved = blockMap[\"delete\"](blockKey);\n\n  if (isExperimentalTreeBlock) {\n    blocksToBeMoved = [];\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\n      blocks.toSeq().skipUntil(function (block) {\n        return block.getKey() === blockKey;\n      }).takeWhile(function (block) {\n        var key = block.getKey();\n        var isBlockToBeMoved = key === blockKey;\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\n      }).forEach(function (block) {\n        blocksToBeMoved.push(block);\n        blocks[\"delete\"](block.getKey());\n      });\n    });\n  }\n\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\n    return v === targetBlock;\n  });\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\n    return v === targetBlock;\n  }).skip(1);\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\n    return [block.getKey(), block];\n  });\n  var newBlocks = OrderedMap();\n\n  if (insertionMode === 'before') {\n    var blockBefore = contentState.getBlockBefore(targetKey);\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\n  } else if (insertionMode === 'after') {\n    var blockAfter = contentState.getBlockAfter(targetKey);\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\n  }\n\n  return contentState.merge({\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\n    selectionBefore: contentState.getSelectionAfter(),\n    selectionAfter: contentState.getSelectionAfter().merge({\n      anchorKey: blockKey,\n      focusKey: blockKey\n    })\n  });\n};\n\nmodule.exports = moveBlockInContentState;"],"mappings":"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"},"metadata":{},"sourceType":"script"}