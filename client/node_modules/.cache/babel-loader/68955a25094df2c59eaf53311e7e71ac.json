{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n *\n * This is unstable and not part of the public API and should not be used by\n * production systems. This file may be update/removed without notice.\n */\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar DraftTreeInvariants = {\n  /**\n   * Check if the block is valid\n   */\n  isValidBlock: function isValidBlock(block, blockMap) {\n    var key = block.getKey(); // is its parent's child\n\n    var parentKey = block.getParentKey();\n\n    if (parentKey != null) {\n      var parent = blockMap.get(parentKey);\n\n      if (!parent.getChildKeys().includes(key)) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing parent -> child pointer on %s', key) : void 0;\n        return false;\n      }\n    } // is its children's parent\n\n\n    var children = block.getChildKeys().map(function (k) {\n      return blockMap.get(k);\n    });\n\n    if (!children.every(function (c) {\n      return c.getParentKey() === key;\n    })) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing child -> parent pointer on %s', key) : void 0;\n      return false;\n    } // is its previous sibling's next sibling\n\n\n    var prevSiblingKey = block.getPrevSiblingKey();\n\n    if (prevSiblingKey != null) {\n      var prevSibling = blockMap.get(prevSiblingKey);\n\n      if (prevSibling.getNextSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing nextSibling pointer on %s's prevSibling\", key) : void 0;\n        return false;\n      }\n    } // is its next sibling's previous sibling\n\n\n    var nextSiblingKey = block.getNextSiblingKey();\n\n    if (nextSiblingKey != null) {\n      var nextSibling = blockMap.get(nextSiblingKey);\n\n      if (nextSibling.getPrevSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing prevSibling pointer on %s's nextSibling\", key) : void 0;\n        return false;\n      }\n    } // no 2-node cycles\n\n\n    if (nextSiblingKey !== null && prevSiblingKey !== null) {\n      if (prevSiblingKey === nextSiblingKey) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree has a two-node cycle at %s', key) : void 0;\n        return false;\n      }\n    } // if it's a leaf node, it has text but no children\n\n\n    if (block.text != '') {\n      if (block.getChildKeys().size > 0) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Leaf node %s has children', key) : void 0;\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * Checks that this is a connected tree on all the blocks\n   * starting from the first block, traversing nextSibling and child pointers\n   * should be a tree (preorder traversal - parent, then children)\n   * num of connected node === number of blocks\n   */\n  isConnectedTree: function isConnectedTree(blockMap) {\n    // exactly one node has no previous sibling + no parent\n    var eligibleFirstNodes = blockMap.toArray().filter(function (block) {\n      return block.getParentKey() == null && block.getPrevSiblingKey() == null;\n    });\n\n    if (eligibleFirstNodes.length !== 1) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. More or less than one first node') : void 0;\n      return false;\n    }\n\n    var firstNode = eligibleFirstNodes.shift();\n    var nodesSeen = 0;\n    var currentKey = firstNode.getKey();\n    var visitedStack = [];\n\n    while (currentKey != null) {\n      var currentNode = blockMap.get(currentKey);\n      var childKeys = currentNode.getChildKeys();\n      var nextSiblingKey = currentNode.getNextSiblingKey(); // if the node has children, add parent's next sibling to stack and go to children\n\n      if (childKeys.size > 0) {\n        if (nextSiblingKey != null) {\n          visitedStack.unshift(nextSiblingKey);\n        }\n\n        var children = childKeys.map(function (k) {\n          return blockMap.get(k);\n        });\n\n        var _firstNode = children.find(function (block) {\n          return block.getPrevSiblingKey() == null;\n        });\n\n        if (_firstNode == null) {\n          process.env.NODE_ENV !== \"production\" ? warning(true, '%s has no first child', currentKey) : void 0;\n          return false;\n        }\n\n        currentKey = _firstNode.getKey(); // TODO(T32490138): Deal with multi-node cycles here\n      } else {\n        if (currentNode.getNextSiblingKey() != null) {\n          currentKey = currentNode.getNextSiblingKey();\n        } else {\n          currentKey = visitedStack.shift();\n        }\n      }\n\n      nodesSeen++;\n    }\n\n    if (nodesSeen !== blockMap.size) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. %s nodes were seen instead of %s', nodesSeen, blockMap.size) : void 0;\n      return false;\n    }\n\n    return true;\n  },\n\n  /**\n   * Checks that the block map is a connected tree with valid blocks\n   */\n  isValidTree: function isValidTree(blockMap) {\n    var _this = this;\n\n    var blocks = blockMap.toArray();\n\n    if (!blocks.every(function (block) {\n      return _this.isValidBlock(block, blockMap);\n    })) {\n      return false;\n    }\n\n    return this.isConnectedTree(blockMap);\n  }\n};\nmodule.exports = DraftTreeInvariants;","map":{"version":3,"names":["warning","require","DraftTreeInvariants","isValidBlock","block","blockMap","key","getKey","parentKey","getParentKey","parent","get","getChildKeys","includes","process","env","NODE_ENV","children","map","k","every","c","prevSiblingKey","getPrevSiblingKey","prevSibling","getNextSiblingKey","nextSiblingKey","nextSibling","text","size","isConnectedTree","eligibleFirstNodes","toArray","filter","length","firstNode","shift","nodesSeen","currentKey","visitedStack","currentNode","childKeys","unshift","_firstNode","find","isValidTree","_this","blocks","module","exports"],"sources":["/home/sudhanshu/Documents/combett/node_modules/draft-js/lib/DraftTreeInvariants.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n *\n * This is unstable and not part of the public API and should not be used by\n * production systems. This file may be update/removed without notice.\n */\nvar warning = require(\"fbjs/lib/warning\");\n\nvar DraftTreeInvariants = {\n  /**\n   * Check if the block is valid\n   */\n  isValidBlock: function isValidBlock(block, blockMap) {\n    var key = block.getKey(); // is its parent's child\n\n    var parentKey = block.getParentKey();\n\n    if (parentKey != null) {\n      var parent = blockMap.get(parentKey);\n\n      if (!parent.getChildKeys().includes(key)) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing parent -> child pointer on %s', key) : void 0;\n        return false;\n      }\n    } // is its children's parent\n\n\n    var children = block.getChildKeys().map(function (k) {\n      return blockMap.get(k);\n    });\n\n    if (!children.every(function (c) {\n      return c.getParentKey() === key;\n    })) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing child -> parent pointer on %s', key) : void 0;\n      return false;\n    } // is its previous sibling's next sibling\n\n\n    var prevSiblingKey = block.getPrevSiblingKey();\n\n    if (prevSiblingKey != null) {\n      var prevSibling = blockMap.get(prevSiblingKey);\n\n      if (prevSibling.getNextSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing nextSibling pointer on %s's prevSibling\", key) : void 0;\n        return false;\n      }\n    } // is its next sibling's previous sibling\n\n\n    var nextSiblingKey = block.getNextSiblingKey();\n\n    if (nextSiblingKey != null) {\n      var nextSibling = blockMap.get(nextSiblingKey);\n\n      if (nextSibling.getPrevSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing prevSibling pointer on %s's nextSibling\", key) : void 0;\n        return false;\n      }\n    } // no 2-node cycles\n\n\n    if (nextSiblingKey !== null && prevSiblingKey !== null) {\n      if (prevSiblingKey === nextSiblingKey) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree has a two-node cycle at %s', key) : void 0;\n        return false;\n      }\n    } // if it's a leaf node, it has text but no children\n\n\n    if (block.text != '') {\n      if (block.getChildKeys().size > 0) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Leaf node %s has children', key) : void 0;\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * Checks that this is a connected tree on all the blocks\n   * starting from the first block, traversing nextSibling and child pointers\n   * should be a tree (preorder traversal - parent, then children)\n   * num of connected node === number of blocks\n   */\n  isConnectedTree: function isConnectedTree(blockMap) {\n    // exactly one node has no previous sibling + no parent\n    var eligibleFirstNodes = blockMap.toArray().filter(function (block) {\n      return block.getParentKey() == null && block.getPrevSiblingKey() == null;\n    });\n\n    if (eligibleFirstNodes.length !== 1) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. More or less than one first node') : void 0;\n      return false;\n    }\n\n    var firstNode = eligibleFirstNodes.shift();\n    var nodesSeen = 0;\n    var currentKey = firstNode.getKey();\n    var visitedStack = [];\n\n    while (currentKey != null) {\n      var currentNode = blockMap.get(currentKey);\n      var childKeys = currentNode.getChildKeys();\n      var nextSiblingKey = currentNode.getNextSiblingKey(); // if the node has children, add parent's next sibling to stack and go to children\n\n      if (childKeys.size > 0) {\n        if (nextSiblingKey != null) {\n          visitedStack.unshift(nextSiblingKey);\n        }\n\n        var children = childKeys.map(function (k) {\n          return blockMap.get(k);\n        });\n\n        var _firstNode = children.find(function (block) {\n          return block.getPrevSiblingKey() == null;\n        });\n\n        if (_firstNode == null) {\n          process.env.NODE_ENV !== \"production\" ? warning(true, '%s has no first child', currentKey) : void 0;\n          return false;\n        }\n\n        currentKey = _firstNode.getKey(); // TODO(T32490138): Deal with multi-node cycles here\n      } else {\n        if (currentNode.getNextSiblingKey() != null) {\n          currentKey = currentNode.getNextSiblingKey();\n        } else {\n          currentKey = visitedStack.shift();\n        }\n      }\n\n      nodesSeen++;\n    }\n\n    if (nodesSeen !== blockMap.size) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. %s nodes were seen instead of %s', nodesSeen, blockMap.size) : void 0;\n      return false;\n    }\n\n    return true;\n  },\n\n  /**\n   * Checks that the block map is a connected tree with valid blocks\n   */\n  isValidTree: function isValidTree(blockMap) {\n    var _this = this;\n\n    var blocks = blockMap.toArray();\n\n    if (!blocks.every(function (block) {\n      return _this.isValidBlock(block, blockMap);\n    })) {\n      return false;\n    }\n\n    return this.isConnectedTree(blockMap);\n  }\n};\nmodule.exports = DraftTreeInvariants;"],"mappings":"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"},"metadata":{},"sourceType":"script"}