{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n\nvar UnicodeUtils = require(\"fbjs/lib/UnicodeUtils\");\n\nvar getCorrectDocumentFromNode = require(\"./getCorrectDocumentFromNode\");\n\nvar getRangeClientRects = require(\"./getRangeClientRects\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n/**\n * Return the computed line height, in pixels, for the provided element.\n */\n\n\nfunction getLineHeightPx(element) {\n  var computed = getComputedStyle(element);\n  var correctDocument = getCorrectDocumentFromNode(element);\n  var div = correctDocument.createElement('div');\n  div.style.fontFamily = computed.fontFamily;\n  div.style.fontSize = computed.fontSize;\n  div.style.fontStyle = computed.fontStyle;\n  div.style.fontWeight = computed.fontWeight;\n  div.style.lineHeight = computed.lineHeight;\n  div.style.position = 'absolute';\n  div.textContent = 'M';\n  var documentBody = correctDocument.body;\n  !documentBody ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Missing document.body') : invariant(false) : void 0; // forced layout here\n\n  documentBody.appendChild(div);\n  var rect = div.getBoundingClientRect();\n  documentBody.removeChild(div);\n  return rect.height;\n}\n/**\n * Return whether every ClientRect in the provided list lies on the same line.\n *\n * We assume that the rects on the same line all contain the baseline, so the\n * lowest top line needs to be above the highest bottom line (i.e., if you were\n * to project the rects onto the y-axis, their intersection would be nonempty).\n *\n * In addition, we require that no two boxes are lineHeight (or more) apart at\n * either top or bottom, which helps protect against false positives for fonts\n * with extremely large glyph heights (e.g., with a font size of 17px, Zapfino\n * produces rects of height 58px!).\n */\n\n\nfunction areRectsOnOneLine(rects, lineHeight) {\n  var minTop = Infinity;\n  var minBottom = Infinity;\n  var maxTop = -Infinity;\n  var maxBottom = -Infinity;\n\n  for (var ii = 0; ii < rects.length; ii++) {\n    var rect = rects[ii];\n\n    if (rect.width === 0 || rect.width === 1) {\n      // When a range starts or ends a soft wrap, many browsers (Chrome, IE,\n      // Safari) include an empty rect on the previous or next line. When the\n      // text lies in a container whose position is not integral (e.g., from\n      // margin: auto), Safari makes these empty rects have width 1 (instead of\n      // 0). Having one-pixel-wide characters seems unlikely (and most browsers\n      // report widths in subpixel precision anyway) so it's relatively safe to\n      // skip over them.\n      continue;\n    }\n\n    minTop = Math.min(minTop, rect.top);\n    minBottom = Math.min(minBottom, rect.bottom);\n    maxTop = Math.max(maxTop, rect.top);\n    maxBottom = Math.max(maxBottom, rect.bottom);\n  }\n\n  return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;\n}\n/**\n * Return the length of a node, as used by Range offsets.\n */\n\n\nfunction getNodeLength(node) {\n  // http://www.w3.org/TR/dom/#concept-node-length\n  switch (node.nodeType) {\n    case Node.DOCUMENT_TYPE_NODE:\n      return 0;\n\n    case Node.TEXT_NODE:\n    case Node.PROCESSING_INSTRUCTION_NODE:\n    case Node.COMMENT_NODE:\n      return node.length;\n\n    default:\n      return node.childNodes.length;\n  }\n}\n/**\n * Given a collapsed range, move the start position backwards as far as\n * possible while the range still spans only a single line.\n */\n\n\nfunction expandRangeToStartOfLine(range) {\n  !range.collapsed ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'expandRangeToStartOfLine: Provided range is not collapsed.') : invariant(false) : void 0;\n  range = range.cloneRange();\n  var containingElement = range.startContainer;\n\n  if (containingElement.nodeType !== 1) {\n    containingElement = containingElement.parentNode;\n  }\n\n  var lineHeight = getLineHeightPx(containingElement); // Imagine our text looks like:\n  //   <div><span>once upon a time, there was a <em>boy\n  //   who lived</em> </span><q><strong>under^ the\n  //   stairs</strong> in a small closet.</q></div>\n  // where the caret represents the cursor. First, we crawl up the tree until\n  // the range spans multiple lines (setting the start point to before\n  // \"<strong>\", then before \"<div>\"), then at each level we do a search to\n  // find the latest point which is still on a previous line. We'll find that\n  // the break point is inside the span, then inside the <em>, then in its text\n  // node child, the actual break point before \"who\".\n\n  var bestContainer = range.endContainer;\n  var bestOffset = range.endOffset;\n  range.setStart(range.startContainer, 0);\n\n  while (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\n    bestContainer = range.startContainer;\n    bestOffset = range.startOffset;\n    !bestContainer.parentNode ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Found unexpected detached subtree when traversing.') : invariant(false) : void 0;\n    range.setStartBefore(bestContainer);\n\n    if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== 'inline') {\n      // The start of the line is never in a different block-level container.\n      break;\n    }\n  } // In the above example, range now spans from \"<div>\" to \"under\",\n  // bestContainer is <div>, and bestOffset is 1 (index of <q> inside <div>)].\n  // Picking out which child to recurse into here is a special case since we\n  // don't want to check past <q> -- once we find that the final range starts\n  // in <span>, we can look at all of its children (and all of their children)\n  // to find the break point.\n  // At all times, (bestContainer, bestOffset) is the latest single-line start\n  // point that we know of.\n\n\n  var currentContainer = bestContainer;\n  var maxIndexToConsider = bestOffset - 1;\n\n  do {\n    var nodeValue = currentContainer.nodeValue;\n    var ii = maxIndexToConsider;\n\n    for (; ii >= 0; ii--) {\n      if (nodeValue != null && ii > 0 && UnicodeUtils.isSurrogatePair(nodeValue, ii - 1)) {\n        // We're in the middle of a surrogate pair -- skip over so we never\n        // return a range with an endpoint in the middle of a code point.\n        continue;\n      }\n\n      range.setStart(currentContainer, ii);\n\n      if (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\n        bestContainer = currentContainer;\n        bestOffset = ii;\n      } else {\n        break;\n      }\n    }\n\n    if (ii === -1 || currentContainer.childNodes.length === 0) {\n      // If ii === -1, then (bestContainer, bestOffset), which is equal to\n      // (currentContainer, 0), was a single-line start point but a start\n      // point before currentContainer wasn't, so the line break seems to\n      // have occurred immediately after currentContainer's start tag\n      //\n      // If currentContainer.childNodes.length === 0, we're already at a\n      // terminal node (e.g., text node) and should return our current best.\n      break;\n    }\n\n    currentContainer = currentContainer.childNodes[ii];\n    maxIndexToConsider = getNodeLength(currentContainer);\n  } while (true);\n\n  range.setStart(bestContainer, bestOffset);\n  return range;\n}\n\nmodule.exports = expandRangeToStartOfLine;","map":{"version":3,"names":["UnicodeUtils","require","getCorrectDocumentFromNode","getRangeClientRects","invariant","getLineHeightPx","element","computed","getComputedStyle","correctDocument","div","createElement","style","fontFamily","fontSize","fontStyle","fontWeight","lineHeight","position","textContent","documentBody","body","process","env","NODE_ENV","appendChild","rect","getBoundingClientRect","removeChild","height","areRectsOnOneLine","rects","minTop","Infinity","minBottom","maxTop","maxBottom","ii","length","width","Math","min","top","bottom","max","getNodeLength","node","nodeType","Node","DOCUMENT_TYPE_NODE","TEXT_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","childNodes","expandRangeToStartOfLine","range","collapsed","cloneRange","containingElement","startContainer","parentNode","bestContainer","endContainer","bestOffset","endOffset","setStart","startOffset","setStartBefore","display","currentContainer","maxIndexToConsider","nodeValue","isSurrogatePair","module","exports"],"sources":["/home/sudhanshu/Documents/combett/node_modules/draft-js/lib/expandRangeToStartOfLine.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\nvar UnicodeUtils = require(\"fbjs/lib/UnicodeUtils\");\n\nvar getCorrectDocumentFromNode = require(\"./getCorrectDocumentFromNode\");\n\nvar getRangeClientRects = require(\"./getRangeClientRects\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n/**\n * Return the computed line height, in pixels, for the provided element.\n */\n\n\nfunction getLineHeightPx(element) {\n  var computed = getComputedStyle(element);\n  var correctDocument = getCorrectDocumentFromNode(element);\n  var div = correctDocument.createElement('div');\n  div.style.fontFamily = computed.fontFamily;\n  div.style.fontSize = computed.fontSize;\n  div.style.fontStyle = computed.fontStyle;\n  div.style.fontWeight = computed.fontWeight;\n  div.style.lineHeight = computed.lineHeight;\n  div.style.position = 'absolute';\n  div.textContent = 'M';\n  var documentBody = correctDocument.body;\n  !documentBody ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Missing document.body') : invariant(false) : void 0; // forced layout here\n\n  documentBody.appendChild(div);\n  var rect = div.getBoundingClientRect();\n  documentBody.removeChild(div);\n  return rect.height;\n}\n/**\n * Return whether every ClientRect in the provided list lies on the same line.\n *\n * We assume that the rects on the same line all contain the baseline, so the\n * lowest top line needs to be above the highest bottom line (i.e., if you were\n * to project the rects onto the y-axis, their intersection would be nonempty).\n *\n * In addition, we require that no two boxes are lineHeight (or more) apart at\n * either top or bottom, which helps protect against false positives for fonts\n * with extremely large glyph heights (e.g., with a font size of 17px, Zapfino\n * produces rects of height 58px!).\n */\n\n\nfunction areRectsOnOneLine(rects, lineHeight) {\n  var minTop = Infinity;\n  var minBottom = Infinity;\n  var maxTop = -Infinity;\n  var maxBottom = -Infinity;\n\n  for (var ii = 0; ii < rects.length; ii++) {\n    var rect = rects[ii];\n\n    if (rect.width === 0 || rect.width === 1) {\n      // When a range starts or ends a soft wrap, many browsers (Chrome, IE,\n      // Safari) include an empty rect on the previous or next line. When the\n      // text lies in a container whose position is not integral (e.g., from\n      // margin: auto), Safari makes these empty rects have width 1 (instead of\n      // 0). Having one-pixel-wide characters seems unlikely (and most browsers\n      // report widths in subpixel precision anyway) so it's relatively safe to\n      // skip over them.\n      continue;\n    }\n\n    minTop = Math.min(minTop, rect.top);\n    minBottom = Math.min(minBottom, rect.bottom);\n    maxTop = Math.max(maxTop, rect.top);\n    maxBottom = Math.max(maxBottom, rect.bottom);\n  }\n\n  return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;\n}\n/**\n * Return the length of a node, as used by Range offsets.\n */\n\n\nfunction getNodeLength(node) {\n  // http://www.w3.org/TR/dom/#concept-node-length\n  switch (node.nodeType) {\n    case Node.DOCUMENT_TYPE_NODE:\n      return 0;\n\n    case Node.TEXT_NODE:\n    case Node.PROCESSING_INSTRUCTION_NODE:\n    case Node.COMMENT_NODE:\n      return node.length;\n\n    default:\n      return node.childNodes.length;\n  }\n}\n/**\n * Given a collapsed range, move the start position backwards as far as\n * possible while the range still spans only a single line.\n */\n\n\nfunction expandRangeToStartOfLine(range) {\n  !range.collapsed ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'expandRangeToStartOfLine: Provided range is not collapsed.') : invariant(false) : void 0;\n  range = range.cloneRange();\n  var containingElement = range.startContainer;\n\n  if (containingElement.nodeType !== 1) {\n    containingElement = containingElement.parentNode;\n  }\n\n  var lineHeight = getLineHeightPx(containingElement); // Imagine our text looks like:\n  //   <div><span>once upon a time, there was a <em>boy\n  //   who lived</em> </span><q><strong>under^ the\n  //   stairs</strong> in a small closet.</q></div>\n  // where the caret represents the cursor. First, we crawl up the tree until\n  // the range spans multiple lines (setting the start point to before\n  // \"<strong>\", then before \"<div>\"), then at each level we do a search to\n  // find the latest point which is still on a previous line. We'll find that\n  // the break point is inside the span, then inside the <em>, then in its text\n  // node child, the actual break point before \"who\".\n\n  var bestContainer = range.endContainer;\n  var bestOffset = range.endOffset;\n  range.setStart(range.startContainer, 0);\n\n  while (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\n    bestContainer = range.startContainer;\n    bestOffset = range.startOffset;\n    !bestContainer.parentNode ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Found unexpected detached subtree when traversing.') : invariant(false) : void 0;\n    range.setStartBefore(bestContainer);\n\n    if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== 'inline') {\n      // The start of the line is never in a different block-level container.\n      break;\n    }\n  } // In the above example, range now spans from \"<div>\" to \"under\",\n  // bestContainer is <div>, and bestOffset is 1 (index of <q> inside <div>)].\n  // Picking out which child to recurse into here is a special case since we\n  // don't want to check past <q> -- once we find that the final range starts\n  // in <span>, we can look at all of its children (and all of their children)\n  // to find the break point.\n  // At all times, (bestContainer, bestOffset) is the latest single-line start\n  // point that we know of.\n\n\n  var currentContainer = bestContainer;\n  var maxIndexToConsider = bestOffset - 1;\n\n  do {\n    var nodeValue = currentContainer.nodeValue;\n    var ii = maxIndexToConsider;\n\n    for (; ii >= 0; ii--) {\n      if (nodeValue != null && ii > 0 && UnicodeUtils.isSurrogatePair(nodeValue, ii - 1)) {\n        // We're in the middle of a surrogate pair -- skip over so we never\n        // return a range with an endpoint in the middle of a code point.\n        continue;\n      }\n\n      range.setStart(currentContainer, ii);\n\n      if (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\n        bestContainer = currentContainer;\n        bestOffset = ii;\n      } else {\n        break;\n      }\n    }\n\n    if (ii === -1 || currentContainer.childNodes.length === 0) {\n      // If ii === -1, then (bestContainer, bestOffset), which is equal to\n      // (currentContainer, 0), was a single-line start point but a start\n      // point before currentContainer wasn't, so the line break seems to\n      // have occurred immediately after currentContainer's start tag\n      //\n      // If currentContainer.childNodes.length === 0, we're already at a\n      // terminal node (e.g., text node) and should return our current best.\n      break;\n    }\n\n    currentContainer = currentContainer.childNodes[ii];\n    maxIndexToConsider = getNodeLength(currentContainer);\n  } while (true);\n\n  range.setStart(bestContainer, bestOffset);\n  return range;\n}\n\nmodule.exports = expandRangeToStartOfLine;"],"mappings":"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"},"metadata":{},"sourceType":"script"}